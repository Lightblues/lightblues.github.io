<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据可视化 Note | Easonshi's Space</title><meta name="author" content="Easonshi"><meta name="copyright" content="Easonshi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1 数据  数据属性特征  数据值类别  Nominal (labels) Ordinal (ordered) Interval (location of zero arbitrary) Ratio (zero fixed) 注意区分区间型和比值型，后者可以定义乘除法  属性间的距离  比值型下的各种定义   数据预处理  缺失值 噪声值：回归分析、离群点分析 可视化数据清洗 数据整合：多数据源">
<meta property="og:type" content="article">
<meta property="og:title" content="数据可视化 Note">
<meta property="og:url" content="https://lightblues.github.io/posts/b0748cbe/index.html">
<meta property="og:site_name" content="Easonshi&#39;s Space">
<meta property="og:description" content="1 数据  数据属性特征  数据值类别  Nominal (labels) Ordinal (ordered) Interval (location of zero arbitrary) Ratio (zero fixed) 注意区分区间型和比值型，后者可以定义乘除法  属性间的距离  比值型下的各种定义   数据预处理  缺失值 噪声值：回归分析、离群点分析 可视化数据清洗 数据整合：多数据源">
<meta property="og:locale">
<meta property="og:image" content="https://lightblues.github.io/img/CowboyBepop/cb-3.jpg">
<meta property="article:published_time" content="2020-08-11T20:41:10.000Z">
<meta property="article:modified_time" content="2022-10-08T15:36:21.780Z">
<meta property="article:author" content="Easonshi">
<meta property="article:tag" content="可视化">
<meta property="article:tag" content="图像处理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lightblues.github.io/img/CowboyBepop/cb-3.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lightblues.github.io/posts/b0748cbe/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="code-5Y8by4jIW3"/><link rel="manifest" href="/"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?07cc68228b5c4f4b4d49b36c1d3656c0";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-155100419-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-155100419-1');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据可视化 Note',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-08 23:36:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Easonshi's Space" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">88</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">113</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/techNotes/"><i class="fa-fw fas fa-sticky-note"></i><span> Notes</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Galleries</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> Books</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movies</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> About</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-address-card"></i><span> About</span></a></li><li><a class="site-page child" href="/timeline/"><i class="fa-fw fas fa-calendar-alt"></i><span> Timeline</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/CowboyBepop/cb-3.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Easonshi's Space</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/techNotes/"><i class="fa-fw fas fa-sticky-note"></i><span> Notes</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Galleries</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> Books</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movies</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> About</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-address-card"></i><span> About</span></a></li><li><a class="site-page child" href="/timeline/"><i class="fa-fw fas fa-calendar-alt"></i><span> Timeline</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据可视化 Note</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-08-11T20:41:10.000Z" title="Created 2020-08-12 04:41:10">2020-08-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-10-08T15:36:21.780Z" title="Updated 2022-10-08 23:36:21">2022-10-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Notes/">Notes</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Notes/major/">major</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">10.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>35min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据可视化 Note"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="数据">1 数据</h2>
<ul>
<li>数据属性特征
<ul>
<li>数据值类别
<ul>
<li>Nominal (labels)</li>
<li>Ordinal (ordered)</li>
<li>Interval (location of zero arbitrary)</li>
<li>Ratio (zero fixed)</li>
<li>注意区<strong>分区间型和比值型</strong>，后者可以定义乘除法</li>
</ul></li>
<li>属性间的距离
<ul>
<li>比值型下的各种定义</li>
</ul></li>
</ul></li>
<li>数据预处理
<ul>
<li>缺失值</li>
<li>噪声值：回归分析、离群点分析</li>
<li>可视化数据清洗</li>
<li>数据整合：多数据源</li>
</ul></li>
<li>数据存储
<ul>
<li>文件形式：CSV、HTML、XML</li>
<li>数据库</li>
<li>数据仓库 data warehouse</li>
</ul></li>
</ul>
<h2 id="image-图像">2.0 Image 图像</h2>
<ul>
<li>从图像到数字图像
<ul>
<li>天文、医学……</li>
<li>采样 sampling</li>
<li>量化 quantization</li>
</ul></li>
<li>分辨率
<ul>
<li>Radiometric resolution 量化的大小</li>
<li>Geometric resolution 通常意义下的分辨率</li>
<li>Image resolution 图片尺寸</li>
</ul></li>
<li>存储形式
<ul>
<li>数字图像表达：<span class="math inline">\(f(X)=Y\)</span></li>
<li>Pixel</li>
<li>Coordinates</li>
<li>Gray level</li>
</ul></li>
<li>亮度和对比度
<ul>
<li>视觉：brightness adaptation level</li>
<li>Weber ratio</li>
<li>Contrast</li>
</ul></li>
<li>坐标系/医学影像坐标系
<ul>
<li>医学影像中不同的坐标系</li>
<li>图像坐标-世界坐标的变换</li>
<li><span class="math inline">\([w_x,w_y,w_z,1]&#39;=M_{I2W}\times [i,j,k,1]&#39;\)</span></li>
<li>右侧是图像坐标系中的坐标，注意 M 是一个 <span class="math inline">\(3\times 4\)</span> 矩阵，另加的一个维度用于平移。</li>
</ul></li>
</ul>
<h2 id="pixel-operation-图像像素操作">2.1 Pixel operation 图像像素操作</h2>
<ul>
<li>Matrix persentation 以矩阵的形式对于图像进行表示</li>
<li>Neighbors of a pixel</li>
<li>Distance between pixels</li>
<li>Elementwise ops</li>
<li>Pixel ops
<ul>
<li>Single pixel op 如下面的灰度值变换</li>
<li><strong>Neighbothood op</strong> 基于邻域的操作，很多算法的思想都有设计，如局部的直方图算法、插值等</li>
<li>Geometric spatial transformation 空间变换，在 9.0 中讲到</li>
<li>Image intensity as r.v.</li>
</ul></li>
</ul>
<h2 id="intensity-transform-灰度值变换">3.1 Intensity transform 灰度值变换</h2>
<ul>
<li>Contrast enhancement</li>
<li>Negative 灰度值取反</li>
<li>Logarithmic</li>
<li><p><strong>Power-law transformation</strong> 通过控制系数 γ 来调节凸显的部分，例如 γ 越大，灰度值高的区域对比度越高</p></li>
<li><p>Contrast stretching 自定义变换曲线 <span class="math inline">\(T(r)\)</span></p></li>
<li><p>Intensity-Level Slicing 凸显灰度值在一定区间内的部分，其余部分置零或是原样输出</p></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051953690223.jpg" /></p>
<h2 id="histogram-based-transform">3.2 Histogram-based transform</h2>
<ul>
<li>Histogram/nD joint histogram</li>
</ul>
<h3 id="histogram-equalization">Histogram equalization</h3>
<ul>
<li>主要的想法是：灰度值集中的某个区域内，导致那部分的图像没有区分度，因此考虑做一个转换使得 Histogram 均匀分布；自然想到了👇的累积分布的转化（叫什么名字来着，统计好像学过）：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051953823865.jpg" /></p>
<ul>
<li>连续情况是很理想的，但在离散状态下，若过多的像素点灰度值为同一个值，效果可能还是不够好</li>
</ul>
<h3 id="histogram-matching-hm">Histogram matching HM</h3>
<ul>
<li>均衡化是对于全局进行的操作，然而有时我们仅仅需要突出某一区间内的灰度值细节，这就是 HM 的思想，将直方图再变换为所需的分布形式</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051953907669.jpg" /></p>
<ul>
<li>其中 T 是把原直方图均衡化，G 是把目标直方图均衡化；这里借由中间的均匀分布进行二次转换</li>
</ul>
<h3 id="local-histogram-processing">Local Histogram processing</h3>
<ul>
<li>一些场景下对于整张图片来进行 HM 是不合适的</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051954061259.jpg" /></p>
<ul>
<li>局部直方图均衡化：对于每一个关注的像素点 <span class="math inline">\(p_i\)</span> ，根据其附近的区域 <span class="math inline">\(RoI_i\)</span> 的直方图，计算转换 <span class="math inline">\(T_i\)</span> ，对于点 <span class="math inline">\(p_i\)</span> 进行更新；</li>
<li>显然，我们对于每个点直接计算其 RoI 的直方图分布是低效的；也即需要 <strong>Efficient update of local histogram</strong>，比如我们把点向右移动一个像素点，可以发现其 RoI 的的变化仅仅是左右的两列，我们利用这些变化的像素点对于 Histogram 进行更新。</li>
</ul>
<h2 id="basic-thresholding">4.0 Basic Thresholding</h2>
<ul>
<li>之间的直方图变换是为了增强对比度，而这里的 Threshold 可以看成是一种特殊的变换：二值化</li>
<li>我们设定一个区间，在这个区间内的像素点灰度值变换为 1，其余部分变换为 0</li>
<li>下面介绍了一些二值化算法（fix threshold），即仅确定通过在数轴上设立一个点分成两部分</li>
</ul>
<h3 id="basic-global-thresholding-bgt">Basic Global Thresholding (BGT)</h3>
<ul>
<li>A simple iterative threshold method, referred to as the <strong>Basic Global Thresholding (BGT)</strong> algorithm</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051954459903.jpg" /></p>
<ul>
<li>其实还挺迷的，想法是，根据这个 threshold 分割出来的直方图，左右两部分的两个均值的平均值正好等于我们设定的 threshold，迭代计算即可；不知道其背后有什么思想</li>
</ul>
<h3 id="otsu-algorithm-大津算法">OTSU Algorithm 大津算法</h3>
<ul>
<li>这个的想法比较简单：想要使得两类像素点之间的类间方差尽可能大</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051954535602.jpg" /></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051954645210.jpg" /></p>
<ul>
<li>定义了几个量 ω 和 μ 分别是灰度值在一定区间内的频率和均值；m 是直接用 <span class="math inline">\(p(i)\)</span> 计算的结果，没有进行归一化，因此有 <span class="math inline">\(m=\omega\mu\)</span> 的关系（下面的符号上进行了简化）</li>
<li>我们的目标是组间方差 <span class="math inline">\(\delta_{bet}^2\)</span> ，好像和机器学习里的定义是一致的？以某一个的频率为权重对 <span class="math inline">\((\mu_{i}-\mu)^2\)</span> 进行求和；</li>
<li>计算的时候，我们希望尽量减少需要计算的量；这里第一行把 <span class="math inline">\(\mu\)</span> 的形式带进去，上下同乘；第二三行进行变换，把 front 类的变量消去；可以看到最终的结果仅包含了 <span class="math inline">\(\mu, \omega_0, m_0\)</span> 三个需要计算的量.</li>
</ul>
<h3 id="entropy-method">Entropy Method</h3>
<ul>
<li>最大化划分出来的两部分灰度值分布的熵之和</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051954723764.jpg" /></p>
<ul>
<li>这里用 b,w 的符号有点混淆，反正就是前景和背景部分各自的熵；</li>
<li>其实和大津算法很相似，后者是以组内/组间方差方差为准则，希望最大化组间方差，即最小化组内方差；而这里的熵算法则是最大化了两个分组内部的熵，同样也是希望是的组内的变异尽可能小。</li>
</ul>
<h3 id="adaptive-thresholding">Adaptive Thresholding</h3>
<ul>
<li><p>also called local (or regional) thresholding</p></li>
<li><p>显然，全局的 threshold 会出现之前 HE 一样的问题，考虑局部处理</p></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051954832737.jpg" /></p>
<ul>
<li>还是一个简单的快速更新均值的公式（一维形式）；另外需要对于边缘进行细致的处理；</li>
<li>可以采用简单的和 RoI 均值的比较设定阈值，公式的常数 C 可能是基于经验的；也可以用如大津算法等自动设定阈值；</li>
</ul>
<h2 id="interpolation-插值">5.0 Interpolation 插值</h2>
<ul>
<li>Four concepts
<ul>
<li>Single-pixel operation</li>
<li>Neighborhood ops</li>
<li>Geometric spatial transformation</li>
<li>Image intensity as random variables</li>
<li>单像素的操作如 2.1 节的灰度值变换；邻域操作如平均模糊化，以及这里的图像插值；</li>
</ul></li>
<li>采样和量化
<ul>
<li>Sampling：digitizing the coordinate values</li>
<li>Quantization: digitizing the amplitude values</li>
<li>如前所述采样和量化有其分辨率</li>
</ul></li>
<li>Interpolation is the process of using known data to <strong>estimate values ar unknown locations</strong>
<ul>
<li>Image interpolation is an image resampling methods for image <strong>resizing</strong> (shrinking and zooming)
<ul>
<li>up-sampling and down-sampling</li>
</ul></li>
</ul></li>
<li><strong>Gray-level interpolation</strong> methods for images
<ul>
<li><p>Nearest neighbot interpolation 找最近的那个点即可</p></li>
<li><p>Bilinear interpolation 线性插值，例如，在二维情况下，插值结果是四周各个点的平均，权重的其对角的矩形的面积</p></li>
</ul></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051955010731.jpg" /></p>
<ul>
<li>Cubic polynomial interpolation 上面用了周围的四个点，这里用四周的 16 个点</li>
<li>空间标量场插值
<ul>
<li>图像描述可能不止矩阵等形式，对于一个空间标量场来说，其插值的思想和在正常的笛卡尔系下是一样的，无非是利用连续性的假设，利用周围点对于目标位置加权求和，权重随距离增加而衰减</li>
</ul></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051955208350.jpg" /></p>
<ul>
<li>当然，没有在上面的线性插值那么标准的算法了，例如这里的三角面片来说的，这里定义了两个方向，用了这样的形式定义了权重；注意到这里应该是和矩阵方式的存储一样各条边的长度为 1（尽管现实上不是等长的）；注意到，不同的两根轴的选取所得的结果有所不同；</li>
<li>当然，例如像 cell 为六边形标量场，可以直接以目标点到各定点之间的距离，其倒数的 e 次方为权重进行衰减，考虑到发散情况加上一个平滑项 <span class="math inline">\(({1\over r_i}+\epsilon)^e\)</span> 。</li>
</ul>
<h2 id="filter">5.1 Filter</h2>
<ul>
<li><p>Spatial filter 空间滤波</p>
<ul>
<li>Filter: passing, modifying or rejecting specific frequency</li>
<li>Contrast &amp; Enhancement</li>
<li>Spatial filtering: Linear or Nonlinear</li>
</ul></li>
<li><p>Convolution &amp; Spatial correlation</p></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051955293140.jpg" /></p>
<ul>
<li>有下面的一些性质</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051955362098.jpg" /></p>
<h3 id="smoothing-noise-reduction">Smoothing (noise reduction)</h3>
<ul>
<li><p>平滑操作的背景是为了去噪，例如 X-ray image of a circuit board 中的 salt-and pepper noise 椒盐噪声</p></li>
<li><p>最简单的如 <strong>Averaging filter</strong>，选取卷积核为取平均的大小为 3 的矩阵；</p></li>
<li><p>再如 <strong>Gaussian Filter</strong> 基于二维高斯分布，取不同方差的高斯核，kernel 的大小也会不同； <span class="math display">\[
  w(s,t)=G(s,t)=Ke^{-{s^2+t^2\over 2\sigma^2}}
  \]</span> 一般可取三倍方差范围内的点，例如取 <span class="math inline">\(\sigma=7\)</span>，则 kernel size=21</p></li>
<li><p>再如 <strong>Order-Statistics filter</strong>，如取 Median，这是 nonliner 的；在图像原本没有噪声的情况下，用前两者会有<strong>模糊化</strong>的效果，而这个相对来说好一些。</p></li>
</ul>
<h3 id="edge-detectation">Edge detectation</h3>
<ul>
<li>不同类型的边缘，前面的两个是快速和缓慢变化的边缘，最后一个可以理解成一条线/缝；它们的一些一阶导数和二阶导数呈现右边的形态</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051955509084.jpg" /></p>
<ul>
<li>Image gradient：因此考虑借助图像梯度的信息进行边缘检测；在这样的离散状态下，可以通过不同的方式（只要合理）来定义梯度，都可以描述成一个 kernel</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051955587707.jpg" /></p>
<ul>
<li>这里用单独一个方向的导数矩阵变换可以得到一个方向上的边缘（实现的时候可以不用 kernel 的形式直接算出来即可）；分别计算两个方向的导数，汇总成<strong>梯度值</strong>图像可以实现多方向上的边缘检</li>
</ul>
<h3 id="sharpening-锐化">Sharpening 锐化</h3>
<ul>
<li>（上面的边缘检测似乎只是用到了一阶梯度信息？）这里的锐化是想要凸显出图像的细节特征。一个典型的算法是 <strong>Laplacian filter</strong> 拉普拉斯滤波，用到了二阶梯度的信息，对于「边缘检测」一节中的（一维）边缘图像全部二阶求导；例如对于上一节中的 Step edge，原本直接只要一个单峰的一阶梯度图像，经过求导后会变成有一个正、紧接着一个负的两个小峰；若我们将其取反叠加到原图像上，那么这个边缘会变得更加「明显」。对于其他的情况可以有类似的结论。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051955670240.jpg" /></p>
<ul>
<li>这是一个例子，可以看到 Laplacian 变换之后提取到了边缘信息，叠加之后月球的细节部分更为清晰。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051955744023.jpg" /></p>
<ul>
<li><p>这里用上面的一种梯度公式推导出了 Laplacian kernel，形式上比较好理解；用不同的导数定义可以得到多种形式的 kernel。</p></li>
<li><p><strong>Unsharp masking and highboost filtering</strong>：除了上面的借助二阶梯度的算法，我们可以从另外的角度来进行锐化——之前讲到的 smoothing 可以消去图像中尖锐的信息，现在我们取两者之差即可得到「残差图」，包含了原本图像中尖锐部分的信息；将其叠加在源图像上也可以达到锐化效果，称为 <strong>highboost 算法</strong></p></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051955825298.jpg" /></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051955886201.jpg" /></p>
<ul>
<li><p>总结</p>
<p>Laplacian: <span class="math inline">\(f-w\nabla^2f\)</span></p>
<p>Highboost: <span class="math inline">\(f+k(f-\bar f)\)</span></p>
<p>另外，如果我们采用之前的定义方式，那么 <span class="math display">\[
\nabla^2f=f(-1,0)+f(1,0)+f(0,-1)+f(0,1)+f(0,0)-5f(0,0)=-5(f-\bar f)
\]</span> 于是，两者在一定条件下是等价的。</p></li>
</ul>
<h2 id="频域变换概念">7.0 频域变换概念</h2>
<blockquote>
<p>关于傅立叶变换的部分，之前课上的时候查阅了一些材料，整理了单独的一篇笔记，见 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/easonshi/p/12676491.html" class="uri">https://www.cnblogs.com/easonshi/p/12676491.html</a> 。因此在下面简单罗列不加以说明。</p>
</blockquote>
<ul>
<li><p>傅立叶级数 Fourier Series</p></li>
<li><p>傅立叶变换 Fourier Transform</p></li>
<li><p>傅立叶逆变换</p>
<ul>
<li>统一利用欧拉公式写成指数形式，<strong>注意到傅立叶级数的本质是将一个函数分解到一个函数空间上，其中的系数是对应的表示向量；不断增加周期，原本离散的系数/向量就变成了一个连续的函数，即为「傅立叶变换」，将原本的时空域函数 <span class="math inline">\(f(t)\)</span> 变换到了频率域上的表示 <span class="math inline">\(F(u)\)</span>，而原本的级数公式就变为傅立叶逆变换的形式，两者组成一个傅立叶变换对。</strong></li>
</ul></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051955972537.jpg" /></p>
<h3 id="傅立叶变换对">傅立叶变换对</h3>
<ul>
<li><p>频域和时空域（图像域）</p></li>
<li><p>正弦、余弦项的频率由 u 决定，称傅里叶变换域为频率域；</p></li>
<li><p>对于图像，t 成为时空域</p></li>
<li><p><strong>频谱 frequency spectrum</strong>: <span class="math inline">\(|F(u)|\)</span></p></li>
<li><p><strong>相位 phase angle</strong>: <span class="math inline">\(\theta(u)=arctan[I(u)/R(u)]\)</span></p></li>
<li><p>上面用的是指数形式，虽然简洁但变换后每一个点的函数值都是复数；<strong>我们还是回到经典的基函数为常值函数、正弦、余弦的形式，并且可以看到 <span class="math inline">\(c_n\)</span> 的实部和虚部 <span class="math inline">\(a_n, b_n\)</span> 分别对应了周期相同的正余弦函数上的系数；在此基础上我们定义了频谱和相位</strong>。</p>
<p>下图展示了两张图像的频谱图和相位图</p></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051956062909.jpg" /></p>
<h3 id="常用的变换">常用的变换</h3>
<ul>
<li>首先介绍了 <strong>冲击函数 impulse</strong> <span class="math inline">\(\delta(t)\)</span>，即仅某点有取值，积分为 1；</li>
<li>其具有 <strong>sifting property</strong>，即和某个函数作积分可以「筛选」出其某个点的函数值；</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051956130905.jpg" /></p>
<ul>
<li>离散状态下表现为仅在一点取值为 1；<strong>冲击序列 Impulse train</strong>，即一系列的在 <span class="math inline">\(k\Delta T\)</span> 处的单位冲击 <span class="math display">\[
s_{\Delta T}(t)=\sum_{-\infty}^\infty \delta(t-\Delta T)
\]</span></li>
</ul>
<ol type="1">
<li><strong>box function</strong> 的傅立叶变换，是一个 sinc 函数形式；证明的话利用欧拉公式直接推</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051956374537.jpg" /></p>
<ol start="2" type="1">
<li><strong>常值函数</strong> <span class="math inline">\(f(t)=1\)</span> 的傅立叶变换是一个连续冲击函数，可利用逆变换的唯一性证明</li>
<li>冲击函数的傅立叶变换就相当于作用 shifting property；冲击串的傅立叶变换还是一个冲击串</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051956438277.jpg" /></p>
<h3 id="卷积定理">卷积定理</h3>
<ul>
<li><p>两个函数的卷积 <span class="math display">\[
f(t)*h(t)=\int f(s)h(t-s)ds
\]</span></p></li>
<li><p>一维状态下的卷积定理 <span class="math display">\[
f(t)*h(t)\Leftrightarrow H(u)F(u)\\
f(t)h(t)\Leftrightarrow H(u)*F(u)
\]</span> 即两函数卷积的傅立叶变换等于其对应的变换后函数的乘积；乘积的傅立叶变换等于量函数变换后的卷积。证明的话用到一次变元，在后面二维情况下进行了证明这里略去。</p></li>
</ul>
<h2 id="离散频域变换">7.1离散频域变换</h2>
<h3 id="sampling-reconstruction">Sampling &amp; Reconstruction</h3>
<ul>
<li>采用上面提到的冲击串进行间隔为 <span class="math inline">\(\Delta T\)</span> 的采样，于是采样得到的结果是下面的形式，注意到其可以表示为原函数和采样函数的乘积；</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051956611716.jpg" /></p>
<p>对于采样的结果进行傅立叶变换，利用到<strong>卷积定理</strong>和上面冲击串的卷积形式，可以得到如下结果</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051956690940.jpg" /></p>
<ul>
<li>注意到，对于这一结果，由于对于 n 从负无穷到正无穷进行了求和，所以是一个<strong>周期为 <span class="math inline">\(1/\Delta T\)</span> 的周期函数</strong>；
<ul>
<li>由于这一特性，假设原函数的傅立叶变换结果有上下限，若我们的采样率过小，可能会出现下面的这张图中的混淆现象</li>
</ul></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051956875568.jpg" /></p>
<ul>
<li><p><strong>Sampling theorem （取样定理）</strong></p>
<p>带限函数：<span class="math inline">\(F(u), u\in[-u_{max}, u_{max}]\)</span></p>
<p><strong>奈奎斯特（Nyquist）采样率</strong>：<span class="math inline">\(2u_{max}\)</span></p>
<p>采样间隔：<span class="math inline">\({1\over \Delta T}&gt;2u_{max}\)</span></p>
<ul>
<li>在这样的情况下，我们可以根据变换后的结果重建出原信号而不损失信息</li>
<li>恢复过程中，我们抽取出 <span class="math inline">\([-u_{max}, u_{max}]\)</span> 区间内的部分并乘以 <span class="math inline">\(\Delta T\)</span> 消除系数，就得到了原始的连续函数傅立叶变换结果；要从频域空间恢复时空域信号，施加逆变换即可；</li>
</ul></li>
</ul>
<h3 id="dft-discrete-freqfourier-transform">DFT: discrete freq/Fourier transform</h3>
<ul>
<li>在图像处理中，我们用的显然是离散状态下的傅立叶变换，即取一个周期内的 M 个样本点；注意到在离散状态下需要多出来一个系数以满足相互变换的一致性；</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051956954943.jpg" /></p>
<h3 id="dft-for-2d">DFT for 2D</h3>
<ul>
<li><strong>2D impulse &amp; sifting property</strong> 同样介绍了二维状态下的冲击函数</li>
<li>2D continueous FT pair</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051957037352.jpg" /></p>
<h4 id="d-sampling-sampling-theorem-采样定理">2D sampling &amp; sampling theorem 采样定理</h4>
<ul>
<li><p>在二维状态下，冲击串 <span class="math inline">\(s_{\Delta T\Delta Z}(t,z)-\sum\sum \delta(t-m\Delta T, z-n\Delta Z)\)</span> ，若取样间隔满足 <span class="math display">\[
\Delta T&lt;{1\over 2u_{max}}\\
\Delta Z&lt;{1\over 2v_{max}}
\]</span> 则<strong>连续带限函数可由其一组样本基本无误地恢复</strong>。</p></li>
<li><p>DFT for 2D/3D，注意到同连续形式相比，同样多出来了一个系数</p></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051957463148.jpg" /></p>
<h4 id="一些性质">一些性质</h4>
<p>没有细讲，不过在后面的处理当中必要的部分是将频谱图平移到中心，即这里的对于时空域图像做 <span class="math inline">\((-1)^{x+y}\)</span> 变换</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051957543099.jpg" /></p>
<ul>
<li>频率域的<strong>频谱和相位角</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051957618456.jpg" /></p>
<p>下面可视化地分析了傅立叶变换后得到的结果中，频谱图和相位图的一些性质；我们记下面的一个 box 函数图像为 alpha，图 2 是中心化后的频谱图，图 3 进行了 Log 变换，图 4 是相位图；分别对于 alpha 做平移和卷积，傅立叶变换的结果也相应展示如下，在频谱上的结果是比较直观的，而我们很难从相位图上直观地观察到原图的一些信息；</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051957760904.jpg" /></p>
<p>然而，事实上，（在图像重建上）相位所带的信息要比频谱更为重要。这里记👇的图 1 为 A，图 2 为其相位图，图 3 是仅保留其相位，经过傅立叶逆变换之后重建的图像，可以看到一些边缘的信息；图 4 是仅保留其频谱信息重建出来的结果；更有意思的最后两张图，图 5 用了 A 的相位信息，而频谱没有置零而用了上面的 alpha 的，最后的结果可以模糊地看到小孩；图 6 用了 A 的频谱和 alpha 的相位，最后重建的结果从形态上更像 alpha。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051957875658.jpg" /></p>
<h4 id="二维状态下的离散卷积定理">二维状态下的离散卷积定理</h4>
<p>要注意同样是在卷积定理中前面的一个系数</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051957954059.jpg" /></p>
<blockquote>
<p>2 证明二维变量的离散傅里叶变换的卷积定理即：</p>
</blockquote>
<p><span class="math display">\[
\begin{gathered}
f(x,y)*h(x,y) &lt;==&gt; F(u,v)H(u,v)\\
f(x,y)h(x,y) &lt;==&gt; {1\over MN}F(u,v)*H(u,v)
\end{gathered}
\]</span></p>
<p>其中, <span class="math inline">\(*\)</span> 表示卷积运算。</p>
<p>根据卷积和傅立叶变换公式： <span class="math display">\[
\begin{gathered}
F(u,v) = \sum_{x,y}f(x,y)e^{-j2\pi(ux/M+vy/N)}\\
f(x,y)*h(x,y) = \sum_{m,n}f(m,n)h(x-m,y-n)
\end{gathered}
\]</span></p>
<p>方便起见省略了加和的上标。参考一维情况，先证第一条</p>
<p><span class="math display">\[
\begin{aligned}
\mathbf{F}\{f * g\}(u, v) &amp;=\sum_{x, y}\left(\sum_{m, n} f(m, n) h(x-m, y-n)\right) e^{-j 2 \pi(u x / M+v y / N)} \\
&amp;=\sum_{m, n} f(m, n) e^{-j 2 \pi(u m / M+v n / N)} \sum_{x, y} h(x-m, y-n) e^{-j 2 \pi(u(x-m) / M+v(y-n) / N)} \\
&amp;=\sum_{m, n} f(m, n) e^{-j 2 \pi(u m / M+v n / N)} \sum_{i, j} h(i, j) e^{-j 2 \pi(u i / M+v j / N)} \\
&amp;=F(u, v) H(u, v)
\end{aligned}
\]</span></p>
<p>即 <span class="math display">\[
f(x,y)*h(x,y) &lt;==&gt; F(u,v)H(u,v)
\]</span></p>
<p>下通过逆 FT 公式证第二条</p>
<p><span class="math display">\[
\begin{aligned}
\mathbf F^{-1}\{\frac{1}{MN}F*H\}(x,y)&amp;=\frac{1}{M N} \frac{1}{M N} \sum_{u, v}\left(\sum_{m, n} F(m, n) H(u-m, v-n)\right) e^{j 2 \pi(u x / M+v y / N)} \\
&amp;=\frac{1}{M N} \sum_{m, n} F(m, n) e^{j 2 \pi(m x / M+n y / N)} \frac{1}{M N} \sum_{u, v} H(u-m, v-n) e^{j 2 \pi(x(u-m) / M+y(v-n) / N)} \\
&amp;=\frac{1}{M N} \sum_{m, n} F(m, n) e^{j 2 \pi(m x / M+n y / N)} \frac{1}{M N} \sum_{i, j} H(i, j) e^{j 2 \pi(x i / M+y j / N)} \\
&amp;=f(x, y) h(x, y)
\end{aligned}
\]</span></p>
<p>即 <span class="math display">\[
f(x,y)h(x,y) &lt;==&gt;{1\over MN} F(u,v)*H(u,v)
\]</span></p>
<h2 id="filters-in-frequency-domain">8.1 Filters in frequency domain</h2>
<ul>
<li><p>在时空域中，我们之前讲过 Filter 操作，如简单的平滑操作、Laplacian operator 等</p></li>
<li><p>Basics of filtering in frequency domain</p>
<ul>
<li><p>观察上面的二维傅立叶变换公式，我们可以看到：</p>
<p>当 u=v=0 的时候，傅立叶变换得到的实际上是整个图像的平均灰度值； 当 u,v 较小的时候，低频，对应的是图像中灰度值变换比较缓慢的信息；</p></li>
<li><p>例如，对于👇的这张图来说，我们可以看到频谱图的对角线方向有两个比较明显的高频分量，对应了原图像中的斜向的边缘（灰度值变化大）的信息。</p></li>
</ul></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051958143754.jpg" /></p>
<ul>
<li>频域滤波公式</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051958214260.jpg" /></p>
<p>在图像域内，我们的滤波操作是采用了卷积操作；而根据卷积定理，相应的我们可以在频率域进行两张图像的点积操作，再将其变换到图像域，即上面的公式；</p>
<ul>
<li>下面直观的展示了低通和高通滤波器；低通滤波器可以达到 smooth 的效果；高通滤波器可以进行锐化；第三张图直接上图 2 的高通滤波器上加了一个常数，修正了最终处理结果的亮度；</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051958298161.jpg" /></p>
<p>另外，若直接对原图像进行操作，可能出现 <strong>缠绕错误 wraparound error</strong> ，因此需要将进行 zero padding</p>
<h3 id="频率域步骤五步骤">频率域步骤五步骤</h3>
<ol type="1">
<li>给定大小为 <span class="math inline">\(M\times N\)</span> 的图像 <span class="math inline">\(f(x,y)\)</span> ，填充成大小为 <span class="math inline">\(P\times G\)</span> 的图像 <span class="math inline">\(f_P(x,y)\)</span> ，一般可取为原图像大小的 2 倍；</li>
<li>以 <span class="math inline">\((-1)^{x+y}\)</span> 乘以 <span class="math inline">\(f_p\)</span>，计算 DFT，得到中心化 <span class="math inline">\(F(u,v)\)</span> ；</li>
<li>生成实对称中心化滤波函数 <span class="math inline">\(H(u,v)\)</span>，<span class="math inline">\(G(u,v)=H(u,x)F(u,v)\)</span> ；</li>
<li>计算 IDFT <span class="math inline">\(g_p(x,y)={real[F^{-1}(G(u,v))]}(-1)^{x+y}\)</span> ，逆变换，取其实数部分，在进行去中心化操作；</li>
<li><span class="math inline">\(g_p\)</span> 左上象限提取 <span class="math inline">\(M\times N\)</span> 图像 <span class="math inline">\(g(x,y)\)</span> ；</li>
</ol>
<p>上述过程如下所示，图 1 为原图；图 2 进行了 padding；图 3 进行中心化；图 4 为傅立叶变换结果；应用图 5 的低通滤波器后得到图 6 的结果；逆变换得到图 7，再去除之前施加的中心化算子，取左上角的那部分图像得到图 8</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051958400574.jpg" /></p>
<h3 id="image-smoothing">Image smoothing</h3>
<ul>
<li><p>Ideal lowpass filter，理想低通滤波，即一个类似 box function 的圆柱</p></li>
<li><p><strong>Ringing effect</strong>，直接用的话会出现 Ringing effect 效果；类似于时空域里的 box function 经过变换后得到 sinc 函数的特征，在频率域内的这种函数经过逆变换也会有类似的效果；</p></li>
<li><p><strong>Gaussian lowpass filter GLPF</strong>，常用的是高斯低通滤波 <span class="math display">\[
H(u,v)=e^{-D^2(u,b)/2\sigma^2}
\]</span> 设置不同的方差，可以得到不同的滤波效果；</p></li>
</ul>
<h3 id="image-sharpening">Image sharpening</h3>
<ul>
<li>高通滤波器，简单的可取 <span class="math inline">\(H_{HP}(u,v)=1-H_{LP}(u,v)\)</span></li>
<li>于是有理想高通滤波，高斯高通滤波</li>
<li>对于频率域中的 Laplacian 算子和 Highboost 滤波算子，在频率域中分别有如下的等效算子</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051958497040.jpg" /></p>
<h3 id="选择性滤波">选择性滤波</h3>
<ul>
<li><p>Bandreject and bandpass filters 带阻/带通滤波器</p></li>
<li><p>Notch filters 陷波滤波器</p>
<p>用一个例子来进行说明，我们得到的图片 1 可能出现一些条纹，这在时空域显然是很难去除的；我们转换为频率域得到图 2，横向条纹对应的频谱图分量类似于图 3；因此设计图 4 的滤波器；滤波结果如图 5 所示；图 6 是对于图 3，也即横向条纹对应的频谱分量进行逆变换，直观地展示了这些杂纹；</p>
<p>作业中用到了这个算法，不过找到对应的频谱分量真的有点难 Orz，可能是基于 Python 的手动实现的原因吧，这时候才意识到在图像处理领域中，交互式的设计有多重要；</p></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051958580883.jpg" /></p>
<h2 id="spatial-transform-图像变换">9.0 Spatial Transform 图像变换</h2>
<h3 id="linear-transformation">Linear transformation</h3>
<ul>
<li><p>Rigid transformation 刚性变换：Rigid transformation preserves the angels and distances within the model</p>
<p>包括了平移和旋转</p></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051958702079.jpg" /></p>
<ul>
<li><p>Similarity transformation 相似变换：Similarity transformation adds scaling {s}</p>
<p>增加了伸缩</p></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051958788724.jpg" /></p>
<ul>
<li><p>Affine transformation 仿射变换：Affine transformation applies a function between affine spaces which preserves points, straight lines and planes.</p>
<p>增加了 Shear？</p>
<p>可以用矩阵来表示；保持平行关系</p></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051958886420.jpg" /></p>
<h3 id="nonlinear-transformation">Nonlinear transformation</h3>
<ul>
<li>Thin-Plate Spline 薄板样条</li>
<li>FFD Free-form deformation 自由形变变换</li>
<li>Locally affine 局部仿射</li>
</ul>
<h4 id="ffd-free-form-deformation-自由形变变换">FFD Free-form deformation 自由形变变换</h4>
<ul>
<li>想法还是一个局部效应求和的过程；设定网格状的控制点 P，每个控制点可以发生一个形变 <span class="math inline">\(\Phi\)</span>；这里的想法就是 <span class="math inline">\(X&#39;=X+Q\)</span>，其中的「形变」部分由 X 周围的一些控制点决定；</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051959087044.jpg" /></p>
<p>常见的是三次 B 样条核函数，一个类似于高斯分布的形式（忽略里面的导数曲线）；可以看到 B 样条函数只在 <span class="math inline">\([-2,2]\)</span> 区间内取值；对于一个目标点 X，划出这个区间可以找到与其相邻的四个点，对着四个点的形变量 <span class="math inline">\(\Phi\)</span> 以 X 到控制点的距离所对应的 B 样条核函数的值为权重（注意这四个点之和=1）求和；最后将形变量加到原来的 X 上即可；</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051959171381.jpg" /></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051959246179.jpg" /></p>
<h4 id="locally-affine-局部仿射">Locally affine 局部仿射</h4>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051959327691.jpg" /></p>
<ul>
<li>这里可以在多个区域内进行仿射仿射变换，作为看参考的区域，对于此外的像素点，按照其离这些参考区域的距离倒数的 e 次方衰减作为权重，把这些变换汇总起来；实现各个区域的局部仿射在算法上还是比较复杂的，作业里面用的是一些参考点而非区域。下面是一些效果图</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051959407222.jpg" /></p>
<h3 id="transform-an-image">Transform an image</h3>
<ul>
<li><p>Forward VS Backward (inverse)</p></li>
<li><p>在具体实现的时候，若是前向进行，即对原图像上的每一个像素点，做 T 变换到新的图像，则可能出现其中很多的点没有被映射到的问题；</p></li>
<li><p>因此，更多时候用的是<strong>反向图变换</strong>，对于目标图像的每一个像素点位置，填充原图像上 <span class="math inline">\(T^{-1}(x&#39;)\)</span> 位置的颜色。注意变换之后需要用到插值。</p></li>
<li><p>作业实现了局部仿射的逆变换，摘录报告中的表述如下</p>
<blockquote>
<p>具体而言，算法的输入包括人脸和猩猩脸两张图片，需要利用两者的相关特征，将人脸 <span class="math inline">\(X\)</span> 风格化为猩猩的面部特征，记输出图像为 <span class="math inline">\(Y\)</span>。考虑到图像存储的离散性，采用逆向变换，即若 <span class="math inline">\(X\)</span> 到 <span class="math inline">\(Y\)</span> 的变换为 <span class="math inline">\(Y=T(X)\)</span>，则算法实现其逆变换 <span class="math inline">\(S(Y)=T^{-1}(Y)=X\)</span> 。</p>
<p>对于原图像的若干控制点 <span class="math inline">\(X_i\)</span>，设其经过各自变换后新的坐标点为 <span class="math inline">\(Y_i=G_i(X_i)\)</span> ，则基于局部仿射变换，对于图像中的任意点 <span class="math inline">\(X\)</span>，其变换结果为个变换的加权平均，权重根据该点与各控制点的距离衰减。即 <span class="math display">\[
T(X)=\sum_{i=1}^n w_i(X)G_i(X_i)\\
w_i(X) = {1/d_i(X)^e\over \sum 1/d_i(X)^e}\\
\]</span> 其中 <span class="math inline">\(d_i(X)\)</span> 表示 <span class="math inline">\(X\)</span> 到各控制点 <span class="math inline">\(X_i\)</span> 之间的距离，权重根据距离倒数的 <span class="math inline">\(e\)</span> 次方衰减，并进行归一化。</p>
<p>记 <span class="math inline">\(G_i(X_i)\)</span> 的逆变换为 <span class="math inline">\(G&#39;(Y_i)\)</span> ，则逆变换过程可近似表为 <span class="math display">\[
S(Y)=\sum_{i=1}^n w&#39;_i(Y)G&#39;_i(Y_i)\\ \tag{2.1}
w&#39;_i(Y)={1/d_i&#39;(Y_i)^e\over \sum1/d_i&#39;(Y_i)^e}
\]</span> 其中 <span class="math inline">\(d&#39;_i(Y_i)\)</span> 为 <span class="math inline">\(Y\)</span> 到各控制点 <span class="math inline">\(Y_i\)</span> 的距离。</p>
</blockquote></li>
</ul>
<h2 id="颜色和彩色图像">10.0 颜色和彩色图像</h2>
<ul>
<li><p>颜色、色彩空间</p>
<ul>
<li>光谱</li>
<li>人眼：视杆细胞、视锥细胞</li>
<li>基色：RGB、红黄蓝、青品红黄黑 CMYK（Cyan, Magenta）</li>
<li>颜色视觉障碍</li>
<li>色彩空间
<ul>
<li><strong>RGB 加色法系统</strong> 采用笛卡尔坐标系定义颜色，用处如显示器</li>
<li><strong>CMYK 减色法系统</strong> 白色减去某个颜色，多用于打印机</li>
<li><strong>HSL/HSI 颜色空间</strong>
<ul>
<li>Hue 色调，人类认为的颜色</li>
<li>Saturation 饱和度，纯度，与灰色的距离</li>
<li>Lightness/Intense 亮度，从黑色到亮色</li>
</ul></li>
<li>Lab颜色空间&lt;L,a,b&gt;
<ul>
<li>感知上均匀分布</li>
<li>a, b用来近似“红/绿” 和“黄/蓝”通道</li>
</ul></li>
</ul></li>
<li>色彩转换：颜色空间的转换 #Further reading</li>
</ul></li>
</ul>
<h3 id="彩色图像处理">彩色图像处理</h3>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051959517375.jpg" /></p>
<ul>
<li>根据不同的色彩空间，需要用不同的函数进行变换，例如要对降低一张图像的亮度，在 RGB 空间中对每一个通道进行收缩即可；仅是 CMY 减色法系统中，统一增加数值即可（加起来是黑色）；而在 CMYK 空间中，仅需要调节 K 通道；在 HSL 空间中，单独调节亮度通道即可。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051960296991.jpg" /></p>
<ul>
<li><p>而要计算补色，在 RGB 空间内转置即可；而在 HSI 空间中，将亮度转置（白变黑），纯度不变，而对于色调，想象一个色环，我们要将其映射到「对面」去，或者说变换保持 1/2 的距离，如上图所示。</p></li>
<li><p>注意到，一些算法对于不同的色彩空间需要有不同的设计；例如，对于<strong>基于 Histogram 的算法</strong>，分别在 RGB 通道上操作会有问题，可在 HSI 空间中进行，仅调节亮度 I。</p></li>
<li><p>图像的 <strong>Filter 操作</strong>，下图展示了在 RGB 空间和 HSI 空间的结果：</p></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051959610206.jpg" /></p>
<h2 id="plot---basics">10.1 Plot - basics</h2>
<ul>
<li><p>视觉基础</p>
<ul>
<li><p>视觉：低阶（物理性质）、高阶（识别、分类等，属于认知能力重要组成部分）</p></li>
<li><p>格式塔 Gestalt 理论（可以<strong>指导视觉设计</strong>）</p>
<ul>
<li><p>强调经验和行为的整体性</p>
<p>感知的事情大于眼睛见到的事物</p></li>
<li><p>贴近原则</p>
<p>相似原则</p>
<p>对称性原则</p>
<p>经验原则</p>
<p>连续原则</p>
<p>闭合原则</p>
<p>共势原则 common fate，方向同？</p>
<p>好图原则 good figure</p></li>
</ul></li>
<li><p>视觉感知的相对性：相对性&amp;绝对性，介绍了而一些常见的错视效应</p></li>
</ul></li>
<li><p>视觉编码</p>
<ul>
<li><p>标记和视觉通道</p>
<ul>
<li><strong>标记</strong>：是数据属性到可视化元素映射（图形元素：点线面）</li>
<li><strong>视觉通道</strong>：是数据的值到标记的视觉表现属性的映射（位置、大小、形状、方向、色调、饱和度、亮度……）</li>
</ul></li>
<li><p>视觉通道的概念</p>
<ul>
<li><p><strong>表现力</strong>：视觉通道在编码数据信息时，需要表达且仅表达数据的完整属性</p>
<p>要求视觉通道准确编码数据包含的所有信息；在对数据进行编码的时候，需要尽量忠于原始数据</p></li>
<li><p>不同类型的数据选取不同的通道进行可视化</p></li>
</ul></li>
</ul></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051959704098.jpg" /></p>
<ul>
<li><p>视觉通道的特性</p>
<ul>
<li>不同的视觉通道，人眼对其的感知能力是不同的；如<strong>尺寸/长度</strong>是先行感知的话，<strong>平面位置、颜色</strong>是超线性的，<strong>角度、形状</strong>等式亚线性的。</li>
</ul></li>
</ul>
<h2 id="plot">11.0 Plot</h2>
<ul>
<li><p>统计图介绍</p>
<ul>
<li>部分占整体比例：<strong>饼状图</strong></li>
<li>比较与比例：<strong>柱状图</strong>为例</li>
<li><strong>堆叠图</strong>：相对于柱状图，可以同时加上时间维度</li>
<li><p>趋势与模式：<strong>折线图</strong></p></li>
<li><strong>散点图</strong></li>
<li><p><strong>盒须图/箱线图</strong></p></li>
<li><p>其他…</p></li>
</ul></li>
<li>设计原则
<ul>
<li>数据到可视化的直观映射：确定数据类型、合适编码方式、优先级</li>
<li>视图选择与交互设计：滚动和缩放、颜色修改、更改映射方式</li>
<li>信息密度--数据的筛选</li>
<li>美学因素：坐标轴刻度、网络；标注、图例、标题；正确使用颜色</li>
<li>颜色与透明度：颜色的混合（线性加和）</li>
<li><strong>可视化隐喻</strong>：拟物？</li>
<li>动画与过渡：时间换取空间</li>
</ul></li>
</ul>
<h2 id="map">11.1 Map</h2>
<ul>
<li>地图和地图投影
<ul>
<li>地理坐标表示：经纬度系统</li>
<li>经纬度系统，实质上是用二维坐标描述了一个三维球体表面的位置；然而我们要可视化到二维的屏幕上，就涉及到如何选择<strong>投影</strong>；根据不同的优化原则，有不同的选择（<strong>等角度/正形投影、等面积、等距离/等方位角</strong>）</li>
</ul></li>
<li>著名的<strong>墨卡托投影</strong>，可以保证等角度。因此多用于各种航海地图，导航地图（百度地图，高德地图）；然而，由于不具备等面积特性，所以在远离赤道的区域，两个点之间的距离会远远超过真实值，容易给人带来混乱</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051960933882.jpg" /></p>
<ul>
<li><p><strong>亚尔勃斯投影</strong>，又称等面积圆锥投影，由德国人亚尔勃斯于 1805 年发明，按照原则将地图投影到圆锥面上；由于其保持了等面积，常用于表现国家疆域面积大小的图示中</p></li>
<li><p><strong>等方位角 azimuth 投影</strong>，属于等距投影的一种，地图上任何一点沿着经度线到投影中原点的距离保持不变。</p></li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/List_of_map_projections" class="uri">https://en.wikipedia.org/wiki/List_of_map_projections</a></p></li>
</ul>
<h2 id="地理数据可视化">12.0 地理数据可视化</h2>
<ul>
<li>点数据可视化</li>
<li>线数据：长度属性、连接关系</li>
<li>区域数据可视化，简单介绍了一些
<ul>
<li><strong>Choropleth 地图（等值区间地图）</strong>，在区域内部均匀分布，填上一致的颜色；有时候的问题在于，区域内的数据和数据大小不一致；</li>
<li>于是有了 <strong>Cartogram</strong>，克服了对空间实用的不合理性，它按照地理区域的属性值对各个区域进行适当的变形；有些不同的形变</li>
</ul></li>
</ul>
<h2 id="地图地理数据可视化实现">12.1 地图地理数据可视化实现</h2>
<p>初步讲了两类</p>
<ul>
<li>Python Basemap+Matplotlib</li>
<li>Baidu Echart and PyEchart</li>
</ul>
<h2 id="空间标量场可视化介绍">12.2 空间标量场可视化介绍</h2>
<ul>
<li>一维数据</li>
<li>二维数据：颜色映射、高度映射、等值线映射 iso-contour</li>
<li>三维标量场
<ul>
<li>截面可视化：如三个正交平面或任意角度切片</li>
<li>间接体绘制：等值面提取</li>
<li>直接体绘制</li>
</ul></li>
</ul>
<h2 id="空间标量场可视化-等值线面的计算">13.0 空间标量场可视化 等值线/面的计算</h2>
<ul>
<li>等值线 (isocontour)
<ul>
<li>类似于线性插值的想法，若一条边两端分别大于和小于所关注的值，线性找到所需要的点；把一个正方形中边上至少两个等值线上的点连起来；</li>
<li>分治思想，分出正方形单元；每个点和 C 比较；线性插值；连接线</li>
</ul></li>
<li>等值面 (isosurface)
<ul>
<li>根据不同的点大小分布，等值线计算有 4 种不同的情况；而等值面的计算中，立方体共有 14 中不同的情况。注意这时候，一个 cell 里的分割面不是平面而是一些三角面片。</li>
</ul></li>
<li><strong>Marching Cubes Algorithm</strong> MC
<ul>
<li>对于各点相较于 C 的大小，变成一个二值向量，映射到最终的分割方式；</li>
<li>需要注意的是歧义性问题 <strong>Ambiguity</strong>，例如在二维情况下，对角线上两组点分别是大于/小于 C 的话，可能出现两种分割方式；在三维情况下，可能出现不匹配的问题，从而出现「洞」；解决算法 #further reading</li>
</ul></li>
</ul>
<h2 id="直接体渲染">14.0 直接体渲染</h2>
<ul>
<li><p>直接计算最终可视化里的每一个像素，体绘制中所有体素对最后的图像亮度都有贡献；因此，其在计算量上的需求要高于面渲染</p></li>
<li><p>基于光线投射的直接体绘制方法 Ray casting</p>
<ul>
<li><p>采样重建：体采样</p>
<p>数据分类：体分类，<strong>传输函数设计</strong></p>
<p>光照计算：体光照模型</p>
<p>光学积分：体积分</p></li>
</ul></li>
<li><p>采样的话，除了网格点之外，更为理想的<strong>自适应采样</strong>，即平缓均匀区域增大采样间隔</p>
<ul>
<li>对于采样率的要求：每个体素至少需要 2 个采样点（之前的定理）</li>
</ul></li>
<li>体分类和传输函数
<ul>
<li>我们拿到的数据多为灰度值数据，因此我们需要决定每个体素吸收的值（不透明度α）和发射的部分颜色(RGB）</li>
<li><strong>Transfer funciton</strong>: 一组定义了数据值及其相关属性，不透明度等视觉元素之间的映射关系的函数</li>
<li>主要是其中不透明度函数的设计，原则是：高不透明度对应重要特征、感兴趣的区域；而颜色的设计可以帮助我们进行区域分割；</li>
<li>我们可以利用体素的<strong>标量值、梯度模</strong>等信息构建传输函数，当然还可以加入一些其他的信息帮助设计；</li>
<li>例如，用上面的两个属性构建二维直方图，进行 1. 映射规则设计；2. 光学属性设计。</li>
<li>注意到传输函数的设计很大程度上决定了最终渲染的好坏，用户交互的传输函数是一个很好的方案。</li>
</ul></li>
<li>体光照模型
<ul>
<li>面绘制中的 Phong 光照模型：最终的 <strong>Result color = Ambient color + Diffuse color + Specular color</strong> 即环境光、散射光和反射光的共同作用；</li>
</ul></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051961058456.jpg" /></p>
<ul>
<li>从公式可以看到，最终的颜色三个因素都有影响；环境光仅和物体的属性相关；漫反射和物体法线与光线方向、物体颜色有关，而与视线方向无关；而镜面反射光与光照方向、物体法线方向、视线方向头有关，而与物体颜色无光，还有一个高光系数。</li>
<li><p>这里需要计算法向量，类似之前的「边缘检测」可以表示为 spatial correlation 的形式；当然，更为常用的是<strong>中心差分</strong>，kernel 仅仅是概念上的存在；</p></li>
<li><p>体积分</p></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051961867425.jpg" /></p>
<ul>
<li><p>这里是把视线/屏幕作为原点，连续情况下是进行积分，对于每一个点的颜色值，其权重为从该点发射的光线，经过了前面的所有体素阻隔之后的剩余部分，即式中指数上面对于不透明作积分，取负指数衰减；</p></li>
<li><p>这是一种思路，而在下面的离散情况下（似乎和连续情况并非对应关系），积分变为求和，这里的视角从「不透明度」变为「透明度」，直接以连乘的透明度作为权重作用到发射点的颜色值上；</p></li>
<li><p>工程上，显然直接用上式求 <span class="math inline">\(D_M\)</span> 之前的所有点的一个体积分需要两次循环，复杂度 <span class="math inline">\(O(M^2)\)</span> ；下面讲了两种简化的思路：</p></li>
<li><p>一种是「从后向前积分」，采用 <span class="math inline">\(D_i=C_i+D_{i+1}(1-a_i)\)</span> ，物理意义是从后向前不断有光线叠加，并透过「玻璃」吸收掉一部分，累加到最前面，这样的复杂度变为线性；</p></li>
<li><p>更高效或许是「从前向后积分」 <span class="math display">\[
  D_i=D_{i-1}+C_i(1-A_i)\\
  A_i=A_{i-1}+(1-A_{i-1})a_i=a_i+A_{i-1}(1-a_i)
  \]</span> 这里维护了一个 <span class="math inline">\(A_i\)</span>，是从前向后累计下来的对当前像素的<strong>「总吸收率」</strong>，我们按照从前向后的顺序进行加总；这里的好处是，当总吸收率较大的时候，我们就不需要再计算后面的体素了。下面是伪代码</p></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051961159892.jpg" /></p>
<ul>
<li>根据合成顺序的不同，体绘制方法分为
<ul>
<li><strong>图像空间</strong>扫描的体绘制方法（屏幕），想象屏幕发出视线</li>
<li><strong>物体空间</strong>扫描的体绘制方法（数据），这里是针对数据的每个像素点，叠加到屏幕上</li>
</ul></li>
<li>上面的光线投影法数据图像空间方法，其他的还有一些比较直观的算法</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051961674866.jpg" /></p>
<ul>
<li>这里的 First，即第一次遇到感兴趣的数值 C 时停下来，记录该点深度；也就是通过体绘制的方式所构成的等值面；</li>
<li><p>取 Max，在医学影像中用到如最大密度投影法，进行血管造影/显像。</p></li>
<li><p>下面的「splitting」属于物体空间扫描的体绘制方法，想法也很直观</p></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051961525336.jpg" /></p>
<p>总结如下</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051961423897.jpg" /></p>
<h2 id="三维数据场渲染实现-vtk-nifty-python可视化">14.1 三维数据场渲染实现 VTK + NIFTY + Python可视化</h2>
<ul>
<li><p>这里讲了 VTK <a target="_blank" rel="noopener" href="http://www.vtk.org/" class="uri">http://www.vtk.org/</a>，当然用的 Python 版本</p></li>
<li><p>面渲染，用了 MC 算法</p></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051962348797.jpg" /></p>
<ul>
<li><p>体绘制</p>
<p>直接调用的 vtkVolumeRayCastMapper 类，相关的设置挺流程化的，所以真正实现的时候最为关键的应该是<strong>传输函数的设计</strong>；实验的时候似乎环境光系数、漫反射系数、镜面反射系数等参数也挺重要的。</p></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051962450569.jpg" /></p>
<h2 id="向量张量场数据可视化">15.0 向量张量场数据可视化</h2>
<ul>
<li>这一讲简单介绍了张量场的可视化技巧</li>
</ul>
<h3 id="张量场可视化">张量场可视化</h3>
<ul>
<li>向量场的可视化：包括<strong>图标法、几何法、纹理法、拓扑法</strong>等</li>
</ul>
<h4 id="图标法">图标法</h4>
<ul>
<li>采用的图标主要有：线条、箭头、方向标志符，经典方法：<strong>hedge hogs（刺猬）</strong>，用带方向线段来表示矢量场的一个点图标；</li>
<li>此外，我们可以用其他的视觉通道表示向量场的其他信息，例如对于向量的方向，不同的方向赋予一些颜色</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051962864812.jpg" /></p>
<ul>
<li>这一算法的优点在于实现简单、直观、灵活；然而，缺点也很明显：
<ul>
<li>可视混乱</li>
<li>无法解释数据的内在连续性</li>
<li>难以表达结构特征如涡流等</li>
</ul></li>
</ul>
<h4 id="几何法">几何法</h4>
<ul>
<li>几何法指采用不同类型的几何元素，如线、面、体模拟向量场的特征</li>
<li>这里讲了三类曲线的可视化：<strong>流线、迹线、脉线</strong></li>
<li><strong>流线 stream line</strong> 主要面向的是稳定的向量场，或许不稳定向量场的某一时刻；即在一个静止的向量场中，在某处放下一个点（不考虑质量？），其运动轨迹；</li>
<li><strong>迹线 path line</strong> 是在一个动态的向量场中，某处放置一个点，其运动轨迹；</li>
<li><strong>脉线 streak line</strong> 的意思是，在某一个点持续释放粒子，经过一段时间之后，各个粒子所连成的曲线（在稳定场中，迹线和脉线相同？）；因此这里和上面的两种「轨迹」不太一样，可以想象「烟圈」；</li>
<li>设在 0-3 时刻向量场的方向分别如下所示，则流线迹线脉线区别如下</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051962546881.jpg" /></p>
<h4 id="纹理法">纹理法</h4>
<ul>
<li>点噪音法（spot noise），按照局部流场方向对圆点变形</li>
<li>线积分卷积（line integral convolution, LIC），在流线方向进行卷积操作</li>
</ul>
<h3 id="张量-tensor-场可视化">张量 Tensor 场可视化</h3>
<ul>
<li>主要面向二阶（对称）张量场</li>
<li>想法是对其作特征分解；根据三个特征值的大小关系，可以有 spherical, linear, planar 三种情况</li>
<li>几何图标法，用球、椭球、线等方式可视化这些特征值</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="16051962989851.jpg" /></p>
<ul>
<li>几何：纤维追踪法 Fiber Tracking #further reading</li>
</ul>
<h3 id="多变量空间数据场可视化">多变量空间数据场可视化</h3>
<ul>
<li>降维</li>
<li>对于特定的应用，必须根据数据自身的特点为其选择和设计适用的特征抽取方法和可视化表达方式。</li>
<li>例如，选取不同的视觉通道</li>
<li>图标法可清晰编码多个变量属性，尤其是可表达方向信息</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Easonshi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://lightblues.github.io/posts/b0748cbe/">https://lightblues.github.io/posts/b0748cbe/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/">可视化</a><a class="post-meta__tags" href="/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/">图像处理</a></div><div class="post_share"><div class="social-share" data-image="/img/CowboyBepop/cb-3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/3105dffb/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/CowboyBepop/cb-4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Joplin 尝试 &amp; 资源汇总</div></div></a></div><div class="next-post pull-right"><a href="/posts/26740dc2/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/EVA/eva-3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">社交网络挖掘-Note3</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div><div id="comment-switch"><span class="first-comment">Disqus</span><span class="switch-btn"></span><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Easonshi</div><div class="author-info__description">Neo learner</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">88</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">113</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lightblues" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:oldcitystal@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">🎉 note 试营业</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE"><span class="toc-number">1.</span> <span class="toc-text">1 数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#image-%E5%9B%BE%E5%83%8F"><span class="toc-number">2.</span> <span class="toc-text">2.0 Image 图像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pixel-operation-%E5%9B%BE%E5%83%8F%E5%83%8F%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">2.1 Pixel operation 图像像素操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#intensity-transform-%E7%81%B0%E5%BA%A6%E5%80%BC%E5%8F%98%E6%8D%A2"><span class="toc-number">4.</span> <span class="toc-text">3.1 Intensity transform 灰度值变换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#histogram-based-transform"><span class="toc-number">5.</span> <span class="toc-text">3.2 Histogram-based transform</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#histogram-equalization"><span class="toc-number">5.1.</span> <span class="toc-text">Histogram equalization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#histogram-matching-hm"><span class="toc-number">5.2.</span> <span class="toc-text">Histogram matching HM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#local-histogram-processing"><span class="toc-number">5.3.</span> <span class="toc-text">Local Histogram processing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#basic-thresholding"><span class="toc-number">6.</span> <span class="toc-text">4.0 Basic Thresholding</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#basic-global-thresholding-bgt"><span class="toc-number">6.1.</span> <span class="toc-text">Basic Global Thresholding (BGT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#otsu-algorithm-%E5%A4%A7%E6%B4%A5%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">OTSU Algorithm 大津算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#entropy-method"><span class="toc-number">6.3.</span> <span class="toc-text">Entropy Method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#adaptive-thresholding"><span class="toc-number">6.4.</span> <span class="toc-text">Adaptive Thresholding</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#interpolation-%E6%8F%92%E5%80%BC"><span class="toc-number">7.</span> <span class="toc-text">5.0 Interpolation 插值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#filter"><span class="toc-number">8.</span> <span class="toc-text">5.1 Filter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#smoothing-noise-reduction"><span class="toc-number">8.1.</span> <span class="toc-text">Smoothing (noise reduction)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#edge-detectation"><span class="toc-number">8.2.</span> <span class="toc-text">Edge detectation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sharpening-%E9%94%90%E5%8C%96"><span class="toc-number">8.3.</span> <span class="toc-text">Sharpening 锐化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%91%E5%9F%9F%E5%8F%98%E6%8D%A2%E6%A6%82%E5%BF%B5"><span class="toc-number">9.</span> <span class="toc-text">7.0 频域变换概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AF%B9"><span class="toc-number">9.1.</span> <span class="toc-text">傅立叶变换对</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%98%E6%8D%A2"><span class="toc-number">9.2.</span> <span class="toc-text">常用的变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF%E5%AE%9A%E7%90%86"><span class="toc-number">9.3.</span> <span class="toc-text">卷积定理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E9%A2%91%E5%9F%9F%E5%8F%98%E6%8D%A2"><span class="toc-number">10.</span> <span class="toc-text">7.1离散频域变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sampling-reconstruction"><span class="toc-number">10.1.</span> <span class="toc-text">Sampling &amp; Reconstruction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dft-discrete-freqfourier-transform"><span class="toc-number">10.2.</span> <span class="toc-text">DFT: discrete freq&#x2F;Fourier transform</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dft-for-2d"><span class="toc-number">10.3.</span> <span class="toc-text">DFT for 2D</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#d-sampling-sampling-theorem-%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86"><span class="toc-number">10.3.1.</span> <span class="toc-text">2D sampling &amp; sampling theorem 采样定理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%80%A7%E8%B4%A8"><span class="toc-number">10.3.2.</span> <span class="toc-text">一些性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E7%A6%BB%E6%95%A3%E5%8D%B7%E7%A7%AF%E5%AE%9A%E7%90%86"><span class="toc-number">10.3.3.</span> <span class="toc-text">二维状态下的离散卷积定理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#filters-in-frequency-domain"><span class="toc-number">11.</span> <span class="toc-text">8.1 Filters in frequency domain</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%91%E7%8E%87%E5%9F%9F%E6%AD%A5%E9%AA%A4%E4%BA%94%E6%AD%A5%E9%AA%A4"><span class="toc-number">11.1.</span> <span class="toc-text">频率域步骤五步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#image-smoothing"><span class="toc-number">11.2.</span> <span class="toc-text">Image smoothing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#image-sharpening"><span class="toc-number">11.3.</span> <span class="toc-text">Image sharpening</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%80%A7%E6%BB%A4%E6%B3%A2"><span class="toc-number">11.4.</span> <span class="toc-text">选择性滤波</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spatial-transform-%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2"><span class="toc-number">12.</span> <span class="toc-text">9.0 Spatial Transform 图像变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#linear-transformation"><span class="toc-number">12.1.</span> <span class="toc-text">Linear transformation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nonlinear-transformation"><span class="toc-number">12.2.</span> <span class="toc-text">Nonlinear transformation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ffd-free-form-deformation-%E8%87%AA%E7%94%B1%E5%BD%A2%E5%8F%98%E5%8F%98%E6%8D%A2"><span class="toc-number">12.2.1.</span> <span class="toc-text">FFD Free-form deformation 自由形变变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#locally-affine-%E5%B1%80%E9%83%A8%E4%BB%BF%E5%B0%84"><span class="toc-number">12.2.2.</span> <span class="toc-text">Locally affine 局部仿射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transform-an-image"><span class="toc-number">12.3.</span> <span class="toc-text">Transform an image</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2%E5%92%8C%E5%BD%A9%E8%89%B2%E5%9B%BE%E5%83%8F"><span class="toc-number">13.</span> <span class="toc-text">10.0 颜色和彩色图像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A9%E8%89%B2%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86"><span class="toc-number">13.1.</span> <span class="toc-text">彩色图像处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#plot---basics"><span class="toc-number">14.</span> <span class="toc-text">10.1 Plot - basics</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#plot"><span class="toc-number">15.</span> <span class="toc-text">11.0 Plot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map"><span class="toc-number">16.</span> <span class="toc-text">11.1 Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">17.</span> <span class="toc-text">12.0 地理数据可视化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E5%9B%BE%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AE%9E%E7%8E%B0"><span class="toc-number">18.</span> <span class="toc-text">12.1 地图地理数据可视化实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E6%A0%87%E9%87%8F%E5%9C%BA%E5%8F%AF%E8%A7%86%E5%8C%96%E4%BB%8B%E7%BB%8D"><span class="toc-number">19.</span> <span class="toc-text">12.2 空间标量场可视化介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E6%A0%87%E9%87%8F%E5%9C%BA%E5%8F%AF%E8%A7%86%E5%8C%96-%E7%AD%89%E5%80%BC%E7%BA%BF%E9%9D%A2%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">20.</span> <span class="toc-text">13.0 空间标量场可视化 等值线&#x2F;面的计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%BD%93%E6%B8%B2%E6%9F%93"><span class="toc-number">21.</span> <span class="toc-text">14.0 直接体渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%9C%BA%E6%B8%B2%E6%9F%93%E5%AE%9E%E7%8E%B0-vtk-nifty-python%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">22.</span> <span class="toc-text">14.1 三维数据场渲染实现 VTK + NIFTY + Python可视化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E5%BC%A0%E9%87%8F%E5%9C%BA%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">23.</span> <span class="toc-text">15.0 向量张量场数据可视化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%A0%E9%87%8F%E5%9C%BA%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">23.1.</span> <span class="toc-text">张量场可视化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E6%A0%87%E6%B3%95"><span class="toc-number">23.1.1.</span> <span class="toc-text">图标法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E6%B3%95"><span class="toc-number">23.1.2.</span> <span class="toc-text">几何法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E6%B3%95"><span class="toc-number">23.1.3.</span> <span class="toc-text">纹理法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%A0%E9%87%8F-tensor-%E5%9C%BA%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">23.2.</span> <span class="toc-text">张量 Tensor 场可视化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%8F%98%E9%87%8F%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E5%9C%BA%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">23.3.</span> <span class="toc-text">多变量空间数据场可视化</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/440b3fc6/" title="感 | 理性, 试论善恶"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/Ukiyo-e/ukiyo-e-3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="感 | 理性, 试论善恶"/></a><div class="content"><a class="title" href="/posts/440b3fc6/" title="感 | 理性, 试论善恶">感 | 理性, 试论善恶</a><time datetime="2022-09-22T07:51:12.000Z" title="Created 2022-09-22 15:51:12">2022-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b40421d0/" title="感 | 负债, 又回高中"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/EVA/eva-8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="感 | 负债, 又回高中"/></a><div class="content"><a class="title" href="/posts/b40421d0/" title="感 | 负债, 又回高中">感 | 负债, 又回高中</a><time datetime="2022-09-11T07:49:04.000Z" title="Created 2022-09-11 15:49:04">2022-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2430d599/" title="感 | 欲望, 或论躺平"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/Ukiyo-e/ukiyo-e-2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="感 | 欲望, 或论躺平"/></a><div class="content"><a class="title" href="/posts/2430d599/" title="感 | 欲望, 或论躺平">感 | 欲望, 或论躺平</a><time datetime="2022-09-11T07:47:51.000Z" title="Created 2022-09-11 15:47:51">2022-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/be128d74/" title="感 | 沉浮, 或论封装"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/Fate/fate-7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="感 | 沉浮, 或论封装"/></a><div class="content"><a class="title" href="/posts/be128d74/" title="感 | 沉浮, 或论封装">感 | 沉浮, 或论封装</a><time datetime="2022-09-09T09:29:50.000Z" title="Created 2022-09-09 17:29:50">2022-09-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/92983cd0/" title="赛博漫谈 | git 作为方法"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/SamuraiChamploo/samurai-champloo-2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="赛博漫谈 | git 作为方法"/></a><div class="content"><a class="title" href="/posts/92983cd0/" title="赛博漫谈 | git 作为方法">赛博漫谈 | git 作为方法</a><time datetime="2022-08-26T06:46:20.000Z" title="Created 2022-08-26 14:46:20">2022-08-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/CowboyBepop/cb-3.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Easonshi</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="Increase font size"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="Decrease font size"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://lightblues.github.io/posts/b0748cbe/'
    this.page.identifier = 'posts/b0748cbe/'
    this.page.title = '数据可视化 Note'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://easonshi.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Disqus' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '877a1cc959829e644238',
      clientSecret: '65ce902d8041ba8ba2e11522f1fe629a52882d46',
      repo: 'lightblues.github.io',
      owner: 'lightblues',
      admin: ['lightblues'],
      id: '8469342b095b4dd2071b777fd29eeef7',
      language: 'en',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Disqus' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script>((window.gitter = {}).chat = {}).options = {
  disableDefaultChat: true,
};
document.addEventListener('gitter-sidecar-ready', (e) => {
  const GitterChat = e.detail.Chat
  let chat

  function initGitter () {
    chat = new GitterChat({
      room: 'Lightblues/community',
      activationElement: '#chat_btn'
    });
  }

  initGitter()

  if (false) {
    document.addEventListener('pjax:complete', () => {
      chat.destroy()
      initGitter()
    })
  }

})</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async="async" defer="defer"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>